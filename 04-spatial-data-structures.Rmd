# Spatial Data Structures 

In the realm of geoinformatics, spatial data stands as a cornerstone, offering a lens through which we can view, analyze, and interpret the world around us. At this point in your Master's, you are already familiar with the basic spatial entities of: points, lines, and polygons. These fundamental structures, while simple in concept, form the bedrock of complex spatial analyses and visualizations.

R, with its rich ecosystem of packages, offers a unique perspective on spatial data. Packages like **sf**, **terra**, **stars**, and **spatstat** have been game-changers, allowing us to handle spatial vector, raster and multidemensional data with unprecedented ease and flexibility. 

```{block2, type = 'rmdtip'}
In this lesson, you will get to know the following spatial data structures in R:

1) Vector data structures based on the simple feature specification implemented in package [sf](https://r-spatial.github.io/sf/){target="_blank"}
2) Raster data structures as provided by the package [terra](https://rspatial.org/pkg/){target="_blank"}

You will also learn how to retrieve, assign and modify coordinate systems, projections and transformations of spatial data structures.

```

## Vector Data Structures

Spatial data structures are the foundation upon which geospatial information is built. They provide a systematic framework for organizing and representing geographical entities, ensuring that they can be efficiently processed, analyzed, and visualized. In this section, we'll delve into vector data structures, which are essential for representing discrete spatial entities.

The most common geometry types are points, lines and polygons and their respective "multi" versions.

**Points** are fundamental in geospatial analysis. They are the simplest spatial entities, representing a singular location in space. They have no dimensions, meaning they don't possess length, width, or area. Using the `sf` package, you can create and manipulate point data with ease:

```{r, echo=FALSE, message=FALSE}
library(sf)
```

```{r}

# Create a point
point <- sf::st_point(c(5, 5))

# Convert to sf object
point_sf <- sf::st_sf(geometry = sf::st_sfc(point))

```

```{block2, type = 'rmdtip'}
The operator :: is used to indicate that the functions `st_point`, `st_sf` and `st_sfc` are situated within the library `sf`. This helps avoiding ambiguities in the case functions from different loaded libraries have identical names.
```

The function `st_point` creates a simple feature object from a numeric vector. The object is of the same nature as the numeric vector `c(5,5)`. To convert to an sf-object, the function `st_sf` is used. 

Sf-object are similar in structure as data frames. However, in contrast to data frames, sf-objects have an additional geometry column. The sf-object `point_sf` (created by the code above) contains a single point geometry and no fields:

```{r}

point_sf

```

In principle sf-objects can be treated like data frames. Accordingly, data frame syntax is used to assign fields (table columns) to geometries: 

```{r}

point_sf$name <- c("my location")

```

To stay in GIS terms, records (rows) in a sf-object table may be called `features`. Features can be composed of multiple geometries:

```{r}

# Create three points at locations 3/4, 5/3 and 7/1 as multipoint geometry
point_multi <- sf::st_multipoint(matrix(c(3, 5, 7, 4, 3, 1), c(3, 2)), dim = "XY")

# Convert to sf object
point_sf_multi <- sf::st_sf(geometry = sf::st_sfc(point_multi))

plot(point_sf_multi)

```

Plotting the metadata of sf-object `point_sf_multi` in the console reveals that `Geometry type` is `Multipoint` and that no coordinate reference system has been defined (`CRS: NA`):

```{r}

point_sf_multi

```

Alternatively, the function `st_crs` may be used extract coordinate system information from an sf-object:

```{r}

sf::st_crs(point_sf_multi)

```

In case when a CRS is missing or the wrong CRS is set, the function `st_crs` is used:

```{r}

# Assign WGS84 as CRS
# 4326 is the EPSG code of WGS84
sf::st_crs(point_sf_multi) <- 4326

```

```{block2, type = 'rmdtip'}

EPSG-Codes of other reference systems can be found [here.](https://spatialreference.org/ref/epsg/?search=4326&srtext=Search){target="_blank"}

```

Now we transform the sf-object to [EPSG 3416](https://spatialreference.org/ref/epsg/3416/){target="_blank"} (Austrian Lambert Projection) with function `st_transform`:

```{r}

# Assign NAD27 as CRS
point_sf_multi_transform <- sf::st_transform(point_sf_multi, 3416)

```

Eventually we can compare the two sf-objects with different coordinate systems:

```{r}

par(mfrow=c(1,2)) # both plots together
plot(sf::st_geometry(point_sf_multi_transform), main = "EPSG: 3416")
plot(sf::st_geometry(point_sf_multi), main = "EPSG: 4326")

```

The same syntax and functions can be used to deal with **line or polygon** data. The following drop-downs contain two simple examples.

<details closed>
<summary><ins>**Create Line Feature!**</ins></summary>
<p><i><font color="grey">

Lines are sequences of points. They're instrumental in representing pathways, routes, or any linear feature. Here's how you can create a line using `sf`:

```{r}
# Create a line from a matrix of coordinates
line <- st_linestring(matrix(1:6, 3, 2))

# Convert to spatial feature
line_sf <- st_sf(geometry = st_sfc(line))

# Plot the line
plot(line_sf)

```
    
</font></i>
</p>
</details> 


<details closed>
<summary><ins>**Create Polygon Feature!**</ins></summary>
<p><i><font color="grey">

Polygons are closed shapes, perfect for representing areas with defined boundaries. Here's a demonstration using sf and its st_polygon function:

```{r}

# Create a matrix of coordinates
coords <- matrix(c(2,2, 4,4, 4,2, 2,2), ncol = 2, byrow = TRUE)

# Create a list of matrices (in this case, just one matrix)
list_of_coords <- list(coords)

# Create the polygon
polygon <- st_polygon(list_of_coords)

# Convert to spatial feature
polygon_sf <- st_sf(geometry = st_sfc(polygon))

# Plot the polygon
plot(polygon_sf)
```
    
</font></i>
</p>
</details>

```{block2, type = 'rmdexercise'}

The code above successfully creates and plots a polygon. However, imagine if the last coordinate in the coordinate matrix (2,2) was mistakenly omitted.

Consider following Questions:

1. What error would you expect to encounter if the last coordinate was omitted?
2. Why is the last coordinate crucial for the creation of the polygon?

<details closed>
<summary><ins>**Solution!**</ins></summary>
<p><i><font color="grey">

1. If the last coordinate was omitted, you would encounter the following error:

`Error in MtrxSet(x, dim, type = "POLYGON", needClosed = TRUE) : polygons not (all) closed`

  A breakdown of what the error message is conveying:
  
  - `MtrxSet(x, dim, type = "POLYGON", needClosed = TRUE)`: This is the internal function being called to set or validate the matrix representation of the polygon.
  
  - `type = "POLYGON"`: This indicates that the data structure being worked on is in fact a Polygon.
  
  - `needClosed = TRUE`: This is a condition set within the function to ensure that polygons are closed. It checks if the starting and ending coordinates of the polygon are the same.
  
  - `polygons not (all) closed`: This is the main error message, indicating that one or more polygons in your data are not closed, i.e., their starting and ending coordinates don't match.

In practical terms, if you're creating or manipulating polygons, you need to ensure that each polygon's last coordinate is the same as its first coordinate. If not, many spatial operations, analyses, or visualizations might produce incorrect or unexpected results!

2. The last coordinate is crucial because it ensures that the polygon is closed, meaning its starting and ending coordinates are the same.

</font></i>
</p>
</details>
  
```



```{block2, type = 'rmdtip'}

In practice you will not define vector geometries manually. In lesson Read and Write Data you will learn how to load Shapefile data as sf-object in R. 

```

## Raster Data Structures

Whereas man-made infrastructures (streets, buildings, sewage systems etc.) can clearly be delineated and modeled by discrete features, our natural-physical environment (temperature, soil moisture etc.) tends to be continuous by nature and best represented by raster data structures.

Both packages, `sf` and `terra` can handle raster and vector data. Due to its comprehensive toolset and integration with the tidyverse ecosystem (tidyverse will be covered in lesson Data Manipulation), `sf` is predominantly used for discrete vector data structures. Until quite recently, the package [`raster`](https://cran.r-project.org/web/packages/raster/index.html){target="_blank"} has been the most popular resource to work with continuous data in R. This package is being replaced by `terra` (see [here](https://psfaculty.plantsciences.ucdavis.edu/plant/AdditionalTopics_Transition.pdf){target="_blank"} for more information). 

Accordingly, in this chapter we will focus on the more modern `terra` package that offers several advantages over its predecessor: 

- Efficiency: Terra is optimized for speed and uses less memory, making it more efficient for large datasets.
- Flexibility: It supports raster, vector, and time-series data, providing a one-stop solution for various spatial data types.
- Ease of Use: With a simplified and consistent syntax, terra is easier to pick up for newcomers.
- Comprehensive Functions: From raster algebra to resampling and reclassification, terra offers a wide array of functionalities.
- Integration: It's designed to work seamlessly with other R packages, making it easier to integrate into larger workflows.

### Working with SpatRaster objects

A `SpatRaster Object` can be created using function `rast`:

```{r, warning=FALSE, message=FALSE}
# Load the terra package
library(terra)

x <- terra::rast()

x

```

Per default the SpatRaster Object is initialized with a global extent and a spatial resolution of 1 degree. The coordinate reference system is WGS84.

Alternatively, additional arguments may be provided in the function to customize the SpatRaster Object:

```{r, warning=FALSE, message=FALSE}

x <- terra::rast(ncol=100, nrow=100, xmin=797422, xmax=807387, ymin=5298037, ymax=5306341, crs = "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ")

x

```

In the example above, arguments such as the number of grid rows and columns (`nrow` and `ncol`) as well as the grid extent (`xmin`, `xmax`, `ymin` and `ymax`) were defined. The raster cell resolution is a result of these inputs (`x=99.65`, `y=83.04`). 

According to the [documentation of the `rast` function](https://www.rdocumentation.org/packages/terra/versions/1.7-46/topics/rast){target="_blank"}, the coordinate reference system can be specified in `PROJ.4`, `WKT` or `authority:code` notation. In the given example `WGS84 UTM 33N` is encoded in `PROJ.4`. To find the desired encoding, it is recommended to first search for a CRS on the [Spatial Reference Website](https://spatialreference.org/){target="_blank"}. The `PROJ.4` is one out of many formats (e.g. EPSG code, WKT, GML etc.) that are provided in the search results.

```{block2, type = 'rmdexercise'}

The SpatRaster Object has an extent that covers the City of Salzburg, which is completely within UTM Zone 33N. Search for the `PROJ.4` encoding of `WGS84 UTM 33N` on the [Spatial Reference Site.](https://spatialreference.org/){target="_blank"}

<details closed>
<summary><ins>**Solution!**</ins></summary>
<p><i><font color="grey">

+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs 

</font></i>
</p>
</details>

```

In order to change the coordinate reference system to `WGS84 UTM 33N` and to change the spatial resolution to 100m, the terra-functions `project` and `res` can be used:

```{r, warning=FALSE, message=FALSE}

y <- terra::project(x, "+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
terra::res(y) <- 100
y

```

Note that the number of rows and column was changed to enable a raster resolution of 100m. Also the extent of the SpatRaster Object object has changed, which indicates a successful projection of the raster grid from `UTM 32` to `UTM 33`.

```{block2, type = 'rmdtip'}

Given that the SpatRaster Object has not coordinate reference system, it can be defined by means of [terra-function `crs`](https://rdrr.io/cran/terra/man/crs.html){target="_blank"}.

```

The objects x and y created in the examples above only consist of a “skeleton”, that is, w....see https://rspatial.org/pkg/3-objects.html

Achtung: Vielleicht war change crs bei sf kein change sondern nur eine neudefinition des Systems ohne Projektion!!!


### Reading Raster Data
```{r}
# Load the terra package
library(terra)

# use the elevation tif file from "spData"
# "The raster data represents elevation in meters and uses WGS84 as a coordinate reference system."
elev <- system.file("raster/elev.tif", package = "spData")
elev <- rast(elev)
elev 

plot(elev) 
```
Once you've read the raster data, you can explore its properties using various functions:

- ncol(r): Number of columns
- nrow(r): Number of rows
- res(r): Resolution (pixel size)
- crs(r): Coordinate Reference System

### Basic Raster Operations
#### Cropping:
What is Raster Cropping?
Raster cropping is the process of selecting a specific area (or "extent") from a larger raster dataset. This is useful when you want to focus your analysis on a particular region.

Why Do We Need to Check the Original Raster's Extent?
Before cropping, it's crucial to know the extent of the original raster. This ensures that the area you want to crop actually exists within the original raster. If the extents don't overlap, you'll get an error.

How to Check the Extent?
You can use the ext() function from the terra package to check the extent of a raster.

```{r}
# Check the extent of the original raster
ext(elev)
```
- How to Crop?
Once you know the extent, you can specify a new extent within that range for cropping.

```{r}
# Define a new extent that is within the original raster's extent
crop_extent <- ext(-1, 1, -1, 1)  # These coordinates are within the original extent

# Crop the raster
elev_cropped <- crop(elev, crop_extent)
elev_cropped

```
### Common Pitfalls
- Non-overlapping Extents: Make sure the cropping extent overlaps with the original raster's extent, otherwise, you'll get an error.
- Coordinate Systems: Ensure that the raster and the extent are in the same coordinate system!


### Resampling Raster Data in Terra
#### What is Resampling?
Resampling is the process of changing the spatial resolution of a raster dataset. This is useful when you want to align multiple rasters that have different resolutions or when you want to change the level of detail in your analysis.

Step 1: Check the Original Resolution
Before resampling, it's important to know the original resolution of your raster. You can use the res() function to check this.

```{r}

res(elev) # shows us the resolution of 0.5. 0.5
plot(elev)
```
Where res is the new resolution.

Step 2: Choose a New Resolution
Decide what the new resolution should be. This could be higher or lower than the original, depending on your needs.
```{r}
# Resample the raster to the new resolution
new_res <- c(0.5, 0.5)  # Example new resolution, for example double the size.

```
Step 3: Perform Resampling
You can use the resample() function to change the resolution. The method can be "nearest", "bilinear", etc., depending on the type of interpolation you want to use.

#```{r}

#elev_resampled <- resample(elev, new_res, method="bilinear")
# Create a target raster with the new resolution
#target_raster <- rast(elev, res=new_res)
# Resample the original raster to match the target raster
#elev_resampled <- resample(elev, target_raster, method="bilinear")
# Check the new resolution
#res(elev_resampled)

#```

Masking: To mask a raster using another raster or vector, you can use the mask() function.

#```{r}
#r_masked <- mask(r, mask_layer)
#```
Where mask_layer is another raster or a vector layer

---

## Multidimensional Data with stars:
- Introduction to stars and its capability to handle multidimensional arrays.
- How stars complements **sf** and **terra** in the R spatial ecosystem.
- Dive Deeper: Handling time series, three-dimensional data, and other multidimensional datasets with **stars**.

## Spatial Indexing
- Introduction to spatial indexing and its importance.
- Would be pretty Important (Atleast, of what I would see it as.)
- Common spatial indexing techniques:
- Quadtree
- R-tree
- KD-tree
- How spatial indexing is implemented in R packages.
- Dive Deeper: Performance benefits of spatial indexing and real-world use cases.

## Topological Relationships
- Discuss spatial relationships like:
- Adjacency (what's next to what)
- Connectivity (how things are connected)
- Containment (what contains what)
- Importance of understanding topological relationships in spatial analysis and how one might implement that in R.

## Introduction to spatstat for point pattern analysis.(**!!! not recommended.. would be beneficial for Chapter 12.**)
- Maybe even as a bridge to "Spatial Statistics Module"? - **altough, that could also be a big one in chapter 12 see ( Applied Spatial Statistics with spatstat)**
- Dive Deeper: Advanced topological operations and their applications in spatial analysis using **spatstat**.

## Practical Applications and Exercises
Exercises focusing on understanding spatial data structures in R, leveraging the capabilities of **sf**, **terra**, **stars**, and **spatstat**... altough, this might be a bit too much and should be lowered.. 

## Coordinate Transformations
- See Chapter 10 prototype 
- Changing the spatial reference system of datasets.
- Discuss the importance of coordinate transformations in spatial analysis.
- Introduce the sf package for these tasks.
- Visualizing the results of coordinate transformations.
- Then, for example Introduce the ggspatial package for visualizing transformed spatial data in conjunction with ggplot2. (**Note that, ggspatial was introduced in chapter 8. Data Visualisation.. Very, very briefly.**)

```{r}
# Example code for coordinate transformations using sf
```

## Raster Resampling and Reprojection
- Adjusting the resolution of raster datasets or changing their projection.
- Introduce the **terra** package for these tasks.
```{r}
# Example code for raster resampling and reprojection using terra
```
