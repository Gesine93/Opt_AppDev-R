# Spatial Data Manipulation

In the previous lesson you have learned to get access to data on a server via Rest API ... few words about OGC Rest API

In this lesson we will....

## Data Acquisition

In the first part of this lesson, we will work with vector data that are used to correctly identify agricultural land parcels in European Union countries. The Austrian Agricultural Agency [AMA](https://www.ama.at/intro){target="_blank"} provides access to Austrian agricultural parcels through an [OGC Rest API - Feature](https://ogcapi.ogc.org/){target="_blank"} interface. The OGC API Features standard is the successor to the earlier OGC Web Feature Service (WFS) specification. 

```{block2, type = 'rmdtip'}

The R-Syntax being used to interact with OGC APIs is the same as described in section "Data API" (see Lesson [Read and write data](#readwrite){target="_blank"}).
  
```

Before we load the data into an R Script, let us take a look at API contents. On the [landing page](https://gis.lfrz.gv.at/ogcapi009501/ogc/features/){target="_blank"} of the web-service go to [collection page](https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections?f=text%2Fhtml){target="_blank"}. On this site you will find an overview of available layers.

Copy the following URL into your browser:

```{}
https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon/items?f=json&limit=10
```

The request returns the first ten features (parameter `limit=10`) of layer `ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon` (parcels of agricultural land as polygons) in a GeoJSON format (parameter `f=json`). 

>GeoJSON is a JSON-based standard that represents simple feature geometries along with their non-spatial attributes.  

On closer inspection of the GeoJSON, you will find coordinate vertices of polygon features as well as feature attributes like `fs_flaeche_ha` (area of parcel in hectares) or `fnar_bezeichnung` (land use).

Alternatively, the parameter `bbox` can be used to filter available resources by means of a bounding box:

```{}
https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon/items?f=json&bbox=14,48,14.02,48.02 
```

To inspect the extent of the data request, paste the coordinates `14,48,14.02,48.02` into [linestrings.com](https://linestrings.com/bbox/){target="_blank"} and press "Display box". 

Once you have specified the URL, the request can be executed in an R Script:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

library(httr2)
library(geojsonsf)
library(sf)

full_url <- "https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon/items?f=json&bbox=14,48,14.02,48.02"

invekos <- httr2::request(full_url) %>%   #Create request
  httr2::req_perform() %>%           #Execute request
  httr2::resp_body_string() %>%      #Extract JSON body as string
  geojsonsf::geojson_sf()            #JSON string to sf object

```

To code above returns 100 polygon features as sf-object that is named `invekos`. 

## Data Cleaning

Once the data is loaded to R, we can inspect the structure of the data in more detail. 

For instance, the `dplyr` function  `glimpse` may be used to see every column name and type:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

dplyr::glimpse(invekos)

```

> `dbl` stands for `double`, which allows you to store numbers as decimals.

The following code returns a subset of sf-object `invekos`:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

library(dplyr)

invekos %>%
  head(2) %>%
  dplyr::select(fnar_bezeichnung, fs_flaeche_ha, geo_id, geometry) %>%
  knitr::kable(., format="html")

```

Field names and entries are in German language. The base R function `colnames()` can be used to rename fields:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

# take subset of invekos object
invekos.sub <- invekos %>%
  dplyr::select(fnar_bezeichnung, fs_flaeche_ha, geo_id, geometry)

# rename fields
colnames(invekos.sub)[1] <- "land_use"
colnames(invekos.sub)[2] <- "area_ha"

```

Entries are renamed by means of `dplyr` functions `mutate` and `case_when`:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

unique(invekos.sub$land_use)  #query unique entries in field 'land_use'

# rename entries 'ACKERLAND' and 'GRÜNLAND'
invekos.sub <- dplyr::mutate(invekos.sub, land_use = 
                               case_when(land_use == 'ACKERLAND' ~ 'arable land',
                               land_use == 'GRÜNLAND' ~ 'grassland', TRUE ~ 'Other'))

#show result
invekos.sub %>%
  head(2) %>%
  knitr::kable(., format="html")

```

To get a first visual impression, we can plot the sf-object by means of the base R `plot()` function:

```{r, echo=TRUE, message=FALSE, warning = FALSE}
plot(invekos.sub[1], main="Land Use", key.pos = 1, key.width = lcm(1.3))
```

By default `plot()` creates a multi-panel plot, one sub-plot for each field of the object. `invekos.sub[1]` limits the output to a single plot of field `land_use`. The function parameter `key.pos = 1` aligns the legend below the map (1=below, 2=left, 3=above and 4=right). `key.width` defines the width of the legend. 

As a next step we can validate the geometry of sf polygons. 

> Remember: Four point coordinates are required to create a closed polygon shape (first and last point need to be identical). A polygon with only three points is classified as having an invalid geometry. 

Sf-Function `st_is_valid` is used to detect invalid geometries:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

sf::st_is_valid(invekos) %>%
  summary()

```

The function returns a logical vector indicating for each geometry whether it is valid. The summary statistic shows that the vector is composed of 100 TRUE values. Accordingly, our geometries are valid. Given that function `st_is_valid` returns FALSE, `st_make_valid` can be used to correct geometries.

```{block2, type = 'rmdexercise'}

In this short exercise we will closely investigate a polygon geometry.

The code below creates a single polygon feature. However, the validity check indicates an invalid geometry. What is problem with this polygon?



```

```{r, echo=TRUE, message=FALSE, warning = FALSE}
# Create a matrix of coordinates
coords <- matrix(c(-1,-1, 1,-1, 1,1, 0,-1, -1, -1), ncol = 2, byrow = TRUE)

# Create a list of matrices (in this case, just one matrix)
list_of_coords <- list(coords)

# Create the polygon
polygon <- st_polygon(list_of_coords)

# Convert to spatial feature
error_sf <- st_sf(geometry = st_sfc(polygon))

sf::st_is_valid(error_sf)

```

<details closed>
<summary><ins>**See solution!**</ins></summary>
<p><font color="grey">
  
Plotting the polygon shows a [sliver polygon](https://en.wikipedia.org/wiki/Sliver_polygon){target="_blank"}. 

```{r, echo=TRUE, message=FALSE, warning = FALSE}

plot(error_sf)

```

Another reason for a non-valid geometry may be the self-intersection of lines. 

</font>
</p>
</details>

## Vector operations

The sf-object is similar in structure as data frames. Accordingly, filtering operations that are based on attributes can be carried out by the help of `dplyr` functions as described in lesson [Data manipulation](#datman){target="_blank"}.

For instance, grassland parcels can be extracted using the `filter()` function:

```{r, echo=TRUE, message=FALSE, warning = FALSE}
invekos.sub %>%
  dplyr::filter(land_use=='grassland') %>%
  {plot(.[1], main="Land Use", key.pos = 1, key.width = lcm(1.3))}
```

> Notice that the `plot()` function is in curly brackets. This is because the dot (used to set the position of the piped value) cannot be indexed directly (`.[1]`). A more comprehensive explanation of the problem can be found [here](https://stackoverflow.com/questions/42385010/using-the-pipe-and-dot-notation){target="_blank"}.

## Geometrical operations

`Sf` provides various geometric predicates such as `st_within`, `st_contains` or `st_crosses`. A full list of available predicates is available [here](https://r-spatial.github.io/sf/reference/geos_binary_pred.html){target="_blank"}. 

Typically, we will use geometric predicates for pairs of simple feature geometry sets (e.g. `st_intersects(<sf-obj1>, <sf-obj2>)`). However, we can also carry out predicate operations based on an individual sf-object:  

```{r, echo=TRUE, message=FALSE, warning = FALSE}

sf::st_intersects(invekos.sub, sparse = TRUE)

```

As a result we get a sparse matrix that reveals numerous intersections between features of the same sf-object `invekos.sub`. For instance, the feature with ID 1 intersects the feature with ID 3. Feature 2 intersects features 22 and 62. In fact, intersections among feature polygons indicate topology errors. To fix these errors, it is recommended to make use of GIS software such as [QGIS](https://www.qgis.org/de/site/){target="_blank"}. R is not yet as advanced in handling topology errors as standard GIS software. 

### Binary operations

To carry out binary operations, we first create a second sf-object that contains the location of farmsteads in our study area (`bbox=14,48,14.02,48.02`). The farm data is in turn loaded via the [AMA Rest API service](https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections?f=text%2Fhtml){target="_blank"}:

```{r, echo=TRUE, message=FALSE, warning = FALSE}


full_url <- "https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_hofstellen_aktuell_point/items?f=json&bbox=14,48,14.02,48.02"

farms <- httr2::request(full_url) %>%   #Create request
  httr2::req_perform() %>%           #Execute request
  httr2::resp_body_string() %>%      #Extract JSON body as string
  geojsonsf::geojson_sf()            #JSON string to sf object

plot(invekos.sub[1], main=NULL, key.pos=NULL, reset = FALSE, col_graticule = "grey")
plot(farms[1], main=NULL, key.pos=NULL, pch = 7, col='red', add = TRUE, cex=1)

```

> Farms were plotted in red together with land parcels. Notice that `plot()` was executed twice to add the farm layer on top of the land parcel layer. More examples on plotting sf-objects with `plot()` are available [here](https://r-spatial.github.io/sf/reference/plot.html){target="_blank"}.

As a next step, we can calculate geometric relations between farms and parcels. To illustrate the concept of binary geometric operations, parcels are allocated among farms based on their distance. 

First, we calculate the distance between farms and parcels:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

dist_m <- sf::st_distance(farms, invekos.sub)

```

Function `st_distance` returns the shortest distance matrix between geometries.

```{block2, type = 'rmdexercise'}

You may wonder why distances are returned in meters even though reference system units are in degrees. 

Use `sf::st_crs()` to query the reference system of sf-objects `farms` and `invekos`. This will reveal that objects use geographic coordinates (WGS 84).

In this short exercise, we will take a closer look at the algorithm that is implemented in function `st_distance`.

Open the [documentation of `st_distance`](https://r-spatial.github.io/sf/reference/geos_measures.html){target="_blank"} to find out how metric distances were derived from geographic coordinates.

<details closed>
<summary><ins>**See solution!**</ins></summary>
<p><font color="grey">

According to the documentation, greater circle distances are computed for geodetic coordinates. Greater circle distance calculations use by default spherical distances. Alternatively, distances can be computed based on an ellipsoidal model. See [Algorithms for geodesics, Journal of Geodesy](https://link.springer.com/article/10.1007/s00190-012-0578-z){target="_blank"} for more information.
  
</font>
</p>
</details>

```

When plotting the complete distance matrix `dist_m`, we see that column 1 contains the distances between the first feature (parcel 1) in sf-object `invekos` and the 10 farm features of sf-object `farms`. Accordingly, the matrix has 100 columns (one column for every parcel) and 10 rows (one row for every farm).

The following line returns the first column of the distance matrix as vector:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

dist_m[, 1]

```

To identify the farm that is located closest to parcel 1, we need to query the index of the minimum value in this vector:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

which(dist_m[, 1] == min(dist_m[, 1]))

```

The index is extracted by function `which`. `which` is a base R function that returns the index of elements that fulfill a condition. In the example above, the index of the minimum value (see function `min`) in vector `dist_m[, 1]` is returned. As a result, the code returns index `1`; i.e. parcel 1 is closest to farm 1.

The demonstrated procedure for detecting closest farms can be executed for ever parcel in a for-loop. The number of the closest farm is appended to a vector named `closest`. This vector is in turn appended as a new column to sf-object `invekos.sub`. And `invekos.sub` is plotted together with `farms`:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

closest <- c()

for (i in 1:100){
  
  out <- which(dist_m[, i] == min(dist_m[, i]))
  
  closest <- c(closest, out)
  
}

cbind(invekos.sub, closest) %>%
  {plot(.[4], main=NULL, key.pos=NULL, reset = FALSE)}

plot(farms[1], main=NULL, key.pos=NULL, pch = 7, col='red', add = TRUE, cex=1)

```

The resulting map shows the shortest distance allocation of agricultural parcels.

In this chapter, we have focused on geometrical operations that return logical matrices (feature is within another feature -> `TRUE` or `FALSE` etc.). Other geometrical operations of the `sf` package are designed to *return new geometries*. For instance, function `st_union` unifies input geometries, `st_buffer` computes a buffer around an input geometry and `st_centroid` returns the center of a polygon as a point feature. 

> See [operations returning a geometry](https://r-spatial.github.io/sf/articles/sf3.html#operations-returning-a-geometry){target="_blank"} for more information.

Moreover, in order to carry out *network operations* on sf-objects you may turn to the package `sfnetworks`. Alternatively, the `igraph` package may be used to work with networks in R. 

## Raster operations

The second important spatial data type that was covered in this module is the `terra` `SpatRaster Object`. So far, we have discussed the structure of `SpatRaster Objects` in [Chapter Raster Data Structures](file:///C:/Users/b1045498/Documents/GitHubRepos/Opt_AppDev-R/docs/spds.html#raster-data-structures){target="_blank"} and how to read and write `SpatRaster Objects` in  [Chapter Read and Write Raster Data](file:///C:/Users/b1045498/Documents/GitHubRepos/Opt_AppDev-R/docs/readwrite.html#read-and-write-raster-data){target="_blank"}. In this section, we will focus on raster manipulation operations like *resampling* and *cropping*. 

> In the examples below, we will use a sample dataset that is provided with the `terra` package ([Download Sample Data](data/terra_sample.tif){target="_blank"}).  

### Resampling Raster Data in Terra

Resampling is the process of changing the spatial resolution of a raster dataset. This is useful when you want to align multiple rasters that have different resolutions or when you want to change the level of detail in your analysis.

The resampling process can be illustrated based on the sample terra sample:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

library(terra)

r <- terra::rast("data/terra_sample.tif") #path may be different on your machine
plot(r, main='SpatRaster from file')

```

Before we change the raster resulution of `SpatRaster Object` r, it is important to know the original resolution of the raster. You can use the `res()` function to check this:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

res(r)

```

The terra resampling function takes a target raster as an input. If we do not have a target raster available, we can simply copy the original raster and assign a new raster resolution value to it:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

r2 <- r
terra::res(r2) <- 80

```

This will delete the values associated the `SpatRaster Object`. Nevertheless raster `r2` can be used as an input to function `resample`. The resolution of `r` will be aligned to the resolution of empty raster `r2`:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

r_resampled <- terra::resample(r, r2, method="bilinear")

res(r2)

plot(r_resampled, main='Resampled 80x80')

```

The new values of raster `r_resampled` are calculated by method `bilinear` interpolation. Other methods are `nearest` or `cubic`. A discussion on what method to use for resampling raster data can be found [here](https://gis.stackexchange.com/questions/2587/deciding-what-interpolation-method-to-use-for-resampling-raster-data){target="_blank"}. 





