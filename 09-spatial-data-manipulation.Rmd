# Spatial Data Manipulation

In the previous lesson you have learned to get access to data on a server via Rest API ... few words about OGC Rest API

In this lesson we will....

## Data Acquisition

In the first part of this lesson, we will work with vector data that are used to correctly identify agricultural land parcels in European Union countries. The Austrian Agricultural Agency [AMA](https://www.ama.at/intro){target="_blank"} provides access to Austrian agricultural parcels through an [OGC Rest API - Feature](https://ogcapi.ogc.org/){target="_blank"} interface. The OGC API Features standard is the successor to the earlier OGC Web Feature Service (WFS) specification. 

```{block2, type = 'rmdtip'}

The R-Syntax being used to interact with OGC APIs is the same as described in section "Data API" (see Lesson [Read and write data](#readwrite){target="_blank"}).
  
```

Before we load the data into an R Script, let us take a look at API contents. On the [landing page](https://gis.lfrz.gv.at/ogcapi009501/ogc/features/){target="_blank"} of the web-service go to [collection page](https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections?f=text%2Fhtml){target="_blank"}. On this site you will find an overview of available layers.

Copy the following URL into your browser:

```{}
https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon/items?f=json&limit=10
```

The request returns the first ten features (parameter `limit=10`) of layer `ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon` (parcels of agricultural land as polygons) in a GeoJSON format (parameter `f=json`). 

>GeoJSON is a JSON-based standard that represents simple feature geometries along with their non-spatial attributes.  

On closer inspection of the GeoJSON, you will find coordinate vertices of polygon features as well as feature attributes like `fs_flaeche_ha` (area of parcel in hectares) or `fnar_bezeichnung` (land use).

Alternatively, the parameter `bbox` can be used to filter available resources by means of a bounding box:

```{}
https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon/items?f=json&bbox=14,48,14.02,48.02 
```

To inspect the extent of the data request, paste the coordinates `14,48,14.02,48.02` into [linestrings.com](https://linestrings.com/bbox/){target="_blank"} and press "Display box". 

Once you have specified the URL, the request can be executed in an R Script:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

library(httr2)
library(geojsonsf)
library(sf)

full_url <- "https://gis.lfrz.gv.at/ogcapi009501/ogc/features/collections/ogcapi009501:INVEKOS_feldstuecke_aktuell_polygon/items?f=json&bbox=14,48,14.02,48.02"

invekos <- httr2::request(full_url) %>%   #Create request
  httr2::req_perform() %>%           #Execute request
  httr2::resp_body_string() %>%      #Extract JSON body as string
  geojsonsf::geojson_sf()            #JSON string to sf object

```

To code above returns 100 polygon features as sf-object that is named `invekos`. 

## Data Cleaning

Once the data is load to R, we can inspect the structure of the data in more detail. 

For instance, the `dplyr` function  `glimpse` may be used to see every column name and type:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

dplyr::glimpse(invekos)

```

> `dbl` stands for `double`, which allows you to store numbers as decimals.

The following code returns a subset of sf-object `invekos`:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

library(dplyr)

invekos %>%
  head(2) %>%
  dplyr::select(fnar_bezeichnung, fs_flaeche_ha, geo_id, geometry) %>%
  knitr::kable(., format="html")

```

Field names and entries are in German language. The base R function `colnames()` can be used to rename fields:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

# take subset of invekos object
invekos.sub <- invekos %>%
  dplyr::select(fnar_bezeichnung, fs_flaeche_ha, geo_id, geometry)

# rename fields
colnames(invekos.sub)[1] <- "land_use"
colnames(invekos.sub)[2] <- "area_ha"

```

Entries are renamed by means of `dplyr` functions `mutate` and `case_when`:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

unique(invekos.sub$land_use)  #query unique entries in field 'land_use'

# rename entries 'ACKERLAND' and 'GRÜNLAND'
invekos.sub <- dplyr::mutate(invekos.sub, land_use = 
                               case_when(land_use == 'ACKERLAND' ~ 'arable land',
                               land_use == 'GRÜNLAND' ~ 'grassland', TRUE ~ 'Other'))

#show result
invekos.sub %>%
  head(2) %>%
  knitr::kable(., format="html")

```

To get a first visual impression, we can plot the sf-object by means of the base R `plot()` function:

```{r, echo=TRUE, message=FALSE, warning = FALSE}
plot(invekos.sub[1], main="Land Use", key.pos = 1, key.width = lcm(1.3))
```

By default `plot()` creates a multi-panel plot, one sub-plot for each field of the object. `invekos.sub[1]` limits the output to a single plot of field `land_use`. The function parameter `key.pos = 1` aligns the legend below the map (1=below, 2=left, 3=above and 4=right). `key.width` defines the width of the legend. 

As a next step we can validate the geometry of sf polygons. Four point coordinates are required to create a closed polygon shape (*Remember:* First and last point need to be identical). A polygon with only three points is classified as having an invalid geometry. Sf-Function `st_is_valid` is used to detect invalid geometries:

```{r, echo=TRUE, message=FALSE, warning = FALSE}

sf::st_is_valid(invekos) %>%
  summary()

```

The function returns a logical vector indicating for each geometry whether it is valid. The summary statistic shows that the vector is composed of 100 TRUE values. Accordingly, our geometries are valid. Given that function `st_is_valid` returns FALSE, `st_make_valid` can be used to correct geometries.

```{block2, type = 'rmdexercise'}

In this short exercise we will closely investigate a polygon geometry.

The code below creates a single polygon feature. However, the validity check indicates an invalid geometry. What is problem with this polygon?



```

```{r, echo=TRUE, message=FALSE, warning = FALSE}
# Create a matrix of coordinates
coords <- matrix(c(-1,-1, 1,-1, 1,1, 0,-1, -1, -1), ncol = 2, byrow = TRUE)

# Create a list of matrices (in this case, just one matrix)
list_of_coords <- list(coords)

# Create the polygon
polygon <- st_polygon(list_of_coords)

# Convert to spatial feature
error_sf <- st_sf(geometry = st_sfc(polygon))

sf::st_is_valid(error_sf)

```

<details closed>
<summary><ins>**See solution!**</ins></summary>
<p><font color="grey">
  
Plotting the polygon shows a [sliver polygon](https://en.wikipedia.org/wiki/Sliver_polygon){target="_blank"}. 

```{r, echo=TRUE, message=FALSE, warning = FALSE}

plot(error_sf)

```

Another reason for a non-valid geometry may be the self-intersection of lines. 

</font>
</p>
</details>
</br>

german attribute names and notations (e.g. Ackerland) to english
filter important information (e.g. fnar_bezeichnung, fs_flaeche_ha, geo_id, geometry), see above
check topology

## Spatial filtering

## Spatial joins

## Geometrical operations

See geometrical operations:
https://r-spatial.github.io/sf/articles/sf3.html#geometrical-operations

Union, buffer, intersect etc.
