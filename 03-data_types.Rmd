# Complex Data Types

In this lecture I will introduce a series of more complex data types that are built on top of the already discussed simple data types 'numeric', 'character' (string) and 'logic' (see [Lecture 1](#intro) 'Simple data types').

```{block2, type = 'rmdtip'}
In this lecture you will get to know the following complex data types:

1) Vector
2) Matrice and Array
3) List
4) Data Frame

```

Complex data types constrain the structure that a container (such as a variable) might take. 

## Vectors

A **Vectors** is an ordered list of values. Vectors can be of any simple type:

    - numeric
    - character
    - logic

However all items in a vector have to be of the same type. A vector can be of any length.

Defining a **vector variable** is similar to the declaration of simple type variables, except that the vector is created by a return function named 'c()' that combines values into a vector: 

```{r, echo=TRUE}
# Declare a vector variable of strings
a_vector <- c("Birmingham", "Derby", "Leicester",
  "Lincoln", "Nottingham", "Wolverhampton")
a_vector
```

```{block2, type = 'rmdtip'}

Note that the second line of the answer provided by R in the console when asking to evaluate the variable starts with `[5]`, as the second line strats with the fifth element of the answer (i.e., the vector)

```

There are also other functions to create vectors such as 'seq()':

```{r, echo=TRUE}
#create vector of real numbers of interval 0.5 in a range between 1 and 7
a_vector <- seq(1, 7, by = 0.5)
a_vector
```

or 'rep()':

```{r, echo=TRUE}
#create vector with 4 identical character string values
a_vector <- rep("Ciao", 4)
a_vector
```

Alternatively, numeric vectors can be created by using the following syntax:

```{r, echo=TRUE}
#create a vector of integer numbers between 1 and 10
a_vector <- (1:10)
a_vector
```


### Vector element selection

Each element of a vector can be retrieved specifying the related **index** between square brackets, after the identifier of the vector. The **first element** of the vector **has index 1**. The following, code retrieves a value of '5' which is the third element of the vector with identifier 'a_vector':

```{r, echo=TRUE}
a_vector <- (3:8)
a_vector[3]
```

A vector of indexes can be used to retrieve more than one element:

```{r, echo=TRUE}
a_vector <- (3:8)
a_vector[c(2, 4)]
```

The values 4 and 6 are returned. These values have the indices 2 and 4 in vector 'a_vector'. Note that the vector containing the indices 2 and 4 is created on the fly (without assigning the return value to a variable).

```{block2, type = 'rmdexercise'}

Now try by yourself. Create a vector that looks like

east_midlands_cities <- c("Derby", "Leicester", "Lincoln", "Nottingham")

, select the last three cities out of the four cities in 'east_midlands_cities' and assign the returned values to a new vector named 'selected_cities'.

<details closed>
<summary><ins>**See solution!**</ins></summary>
<p><i><font color="grey">
  
east_midlands_cities <- c("Derby", "Leicester", "Lincoln", "Nottingham")

my_indexes <- 2:4

selected_cities <- c(east_midlands_cities[my_indexes])
    
</font></i>
</p>
</details> 

```

### Functions on vectors

In R, functions can be used on a vector variable in the same way they are used on simple variables. In this case the selected function will be applied to each element of the vector. The output will be a new vector containing the same number of elements as the input vector. 

For instance, adding a number of ten to a vector of numbers between 1 and 5 will result in a vector of numbers between 11 and 15:

```{r, echo=TRUE}
a_numeric_vector <- 1:5
a_numeric_vector <- a_numeric_vector + 10
a_numeric_vector
```

Accordingly, an sqrt() function applied to the same vector will return a vector containing the square root of every element as a result: 

```{r, echo=TRUE}
a_numeric_vector <- 1:5
a_numeric_vector <- sqrt(a_numeric_vector)
a_numeric_vector
```

We can also produce a vector of type 'logical' by using a condition:

```{r, echo=TRUE}
a_numeric_vector <- 1:5
a_numeric_vector <- a_numeric_vector >= 3
a_numeric_vector
```

While the condition in the example above returns an evaluation of the conditional statement for every element, the function 'any' and 'all' are **overall expressions**. The function 'any()' returns TRUE, if any of the elements satisfy the condition:

```{r, echo=TRUE}
a_numeric_vector <- 1:5
any(a_numeric_vector >= 3)
```

The function 'all' returns TRUE, if all of the elements satisfy the condition:

```{r, echo=TRUE}
a_numeric_vector <- 1:5
all(a_numeric_vector >= 3)
```

```{block2, type = 'rmdtip'}
A **factor** is a data type similar to a vector. However, the values contained in a factor can only be selected from a set of **levels**. Factors will not be covered in the module. For more information on this data type turn to Stefano de Sabbatas video on ['Data Types (see min 9:30)'.](https://sdesabbata.github.io/granolarr/lectures_110/){target="_blank"}
```

## Multi-dimensional data types

### Matrices

So far you have learned about one dimensional data types. **Matrices** are collections of numbers arranged in a two-dimensional rectangular layout.

To create a matrix, two arguments should be provided to the function matrix. The first argument is a vector of values. The second specifies the number of rows and columns:

```{r, echo=TRUE}
a_matrix <- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2))
a_matrix
```

R offers a large number of operators and functions for matrix algebra. For instance, standard mathematical operators are applicable:

```{r, echo=TRUE}
x <- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2))
x
y <- matrix(c(1, 2, 3, 4, 5, 6), c(3, 2))
y
z <- x*y
z
```

A more comprehensive list of matrix algebra operations is provided by [Quick-R](https://www.statmethods.net/advstats/matrix.html){target="_blank"}. 

### Arrays

Variables of the type **array** are higher-dimensional matrices. Just like matrices, to create an array two arguments are required. The first argument is a vector containing the values. The second argument is a vector specifying the depth of each dimension. The following code returns a 3-dimensional array: 

```{r, echo=TRUE}
a3dim_array <- array(1:24, dim=c(4, 3, 2))
a3dim_array
```

### Selection

Subsetting of matrices and arrays works in a very similar way as seen for vectors. However, as these are multi-dimensional objects, one value (or index) needs to be specified for each one of the dimensions.

In the example below we are subsetting the second row and the first and second column of the matrix:

```{r, echo=TRUE}
a_matrix <- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2))
a_matrix
a_matrix[2, c(1, 2)]
```

```{block2, type = 'rmdexercise'}

As an exercise, create an arbitrary 3-dimensional array, retrieve 2 elements from it and write those elements to a new vector variable. Then retrieve 4 elements from the 3-dimensional array and write it to a new matrix variable.

<details closed>
<summary><ins>**See solution!**</ins></summary>
<p><i><font color="grey">
  
a3dim_array <- array(1:24, dim=c(4, 3, 2))

a3dim_array

a_vector <- a3dim_array[3, c(1, 2), 2]

a_vector

a_matrix <- a3dim_array[c(3, 4), c(1, 2), 2]

a_matrix
    
</font></i>
</p>
</details> 

```

### List

Variables of the type **list** can contain elements of different types (including vectors and matrices), whereas elements of vectors are all of the same type.

In the following example I created a list containing the simple types 'character' and 'numeric integer': 

```{r, echo=TRUE}
employee <- list("Christian", 2017)
employee
employee[[1]] # Note the double square brackets for selection
```

In contrast to vectors, matrices or arrays, the selection of list elements requires the use of **double square brackets**. 

A specific type of list is the so called named list. In **named lists** each element has a name, and elements can be selected using their name after the symbol `$`: 

```{r, echo=TRUE}
employee <- list(employee_name = "Christian", start_year = 2017)
employee
employee$employee_name
```

### Data Frame

...data frame also $ for selection....

## Functions on complex types 


<!--
## apply
`apply` applies another function to each level of a set dimension of an array
```{r, echo=TRUE}
apply(a3dim_array, 3, min) # apply on third dimension
apply(a3dim_array, 1, min) # apply on first dimension
apply(a3dim_array, 2, min) # apply on second dimension
```
-->



<!--
## lapply
With `lapply` take care that the function makes sense for *any* element in the list
```{r, echo=TRUE}
various <- list(
  "Some text",
  matrix(c(6, 3, 1, 2), c(2, 2))
)
lapply(various, is.numeric)
```
## Lists: append
The function **append** can be used to append a new element at the end of a list.
```{r, echo=TRUE, eval=FALSE}
various <- list("Stefano", c(2015, 2016), "Lecturer",
                matrix(c(6, 3, 1, 2), c(2, 2)))
various <- append(various, list(c(7, 6, 9, 1))) 
various
```
-->


sapply


tapply


