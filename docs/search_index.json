[["data-wrangling.html", "Lesson 6 Data wrangling 6.1 Preparation 6.2 Data manipulation 6.3 Join", " Lesson 6 Data wrangling In most instances the structure of the available data will not meet the specific requirements to perform the analyses you are interested in. Data analysts typically spend the majority of their time cleaning, filtering, restructuring data as well as harmonizing and joining data from different sources. This lesson introduces to the most common data wrangling operations by means of the dplyr library (part of the Tidyverse libraries), which it offers a grammar for data manipulation. 6.1 Preparation If not yet installed on your machine, install the libraries tidyverse as well as nycflights13 (see Libraries in lesson core Concepts). The code below, loads the data frame flights from the library nycflights13 into the variable flights_from_nyc. We will use this data frame throughout this lesson. library(nycflights13) flights_from_nyc &lt;- nycflights13::flights The operator :: is used to indicate that the data frame flights is situated within the library nycflights13. You can use ::, if you know exactly which library contains the object or function desired. This helps avoiding ambiguities in the case functions from different loaded libraries have identical names. Add both lines above as well as the code snippets provided in the upcoming examples to a new R script file. 6.2 Data manipulation Firstly, inspect the data frame flights_from_nyc by writing it to the console. The library dplyr provides a number of functions to investigate basic characteristics of inputs. For instance, the function count() can be used to count the number of rows of a data frame. The code below provides flights_from_nyc as input to the function. library(tidyverse) library(knitr) flights_from_nyc %&gt;% dplyr::count() %&gt;% knitr::kable() n 336776 In the code example above, we use the so called pipe operator %&gt;%, which is included in tidyverse, as well as a function named kable() of library knitr to render the output. The pipe operator allows us to link a sequence of analysis steps. In the example above the data frame flights_from_nyc is passed into function count() and the output is pased into function kable() to render the result_df The pipe operator is a powerful tool to simplify your code. See this video to learn more about it. The function count() can also be used to count the number rows of a table that have the same value for a given column, usually representing a category. In the example below, the column name origin is provided as an argument to the function count, so rows representing flights from the same origin are counted together  EWR is the Newark Liberty International Airport, JFK is the John F. Kennedy International Airport, and LGA is LaGuardia Airport. flights_from_nyc %&gt;% dplyr::count(origin) %&gt;% knitr::kable() origin n EWR 120835 JFK 111279 LGA 104662 As you can see, the code above is formatted in a way similar to a code block, although it is not a code block. The code goes to a new line after every %&gt;%, and space is added at the beginning of new lines. That is very common in R programming (especially when functions have many parameters) as it makes the code more readable. 6.2.1 Summarise To carry out more complex aggregations, the function summarise() can be used in combination with the function group_by() to summarise the values of the rows of a data frame. Rows having the same value for a selected column (in the example below, the same origin) are grouped together, then values are aggregated based on the defined function (using one or more columns in the calculation). In the example below, the function sum() is applied to the column distance to calculate distance_traveled_from (the total distance travelled by flights starting from each airport). flights_from_nyc %&gt;% dplyr::group_by(origin) %&gt;% dplyr::summarise( mean_distance_traveled_from = mean(distance) ) %&gt;% knitr::kable() origin mean_distance_traveled_from EWR 1056.7428 JFK 1266.2491 LGA 779.8357 6.2.2 Select and filter The function select() can be used to select some columns to output. For instance in the code below, the function select() is used to select the columns origin, dest, and dep_delay, in combination with the function slice_head, which can be used to include only the first n rows (5 in the example below) to output. flights_from_nyc %&gt;% dplyr::select(origin, dest, dep_delay) %&gt;% dplyr::slice_head(n = 5) %&gt;% knitr::kable() origin dest dep_delay EWR IAH 2 LGA IAH 4 JFK MIA 2 JFK BQN -1 LGA ATL -6 The function filter() can instead be used to filter rows based on a specified condition. In the example below, the output of the filter step only includes the rows where the value of month is 11 (i.e., the eleventh month, November). flights_from_nyc %&gt;% dplyr::select(origin, dest, year, month, day, dep_delay) %&gt;% dplyr::filter(month == 11) %&gt;% dplyr::slice_head(n = 5) %&gt;% knitr::kable() origin dest year month day dep_delay JFK PSE 2013 11 1 6 JFK SYR 2013 11 1 105 EWR CLT 2013 11 1 -5 LGA IAH 2013 11 1 -6 JFK MIA 2013 11 1 -3 Notice how filter is used in combination with select. All functions in the dplyr library can be combined, in any other order that makes logical sense. However, if the select step didnt include month, that same column couldnt have been used in the filter step. 6.2.3 Mutate The function mutate() can be used to add a new column to an output table. The mutate step in the code below adds a new column air_time_hours to the table obtained through the pipe, that is the flight air time in hours, dividing the flight air time in minutes by 60. flights_from_nyc %&gt;% dplyr::select(flight, origin, dest, air_time) %&gt;% dplyr::mutate( air_time_hours = air_time / 60 ) %&gt;% dplyr::slice_head(n = 5) %&gt;% knitr::kable() flight origin dest air_time air_time_hours 1545 EWR IAH 227 3.783333 1714 LGA IAH 227 3.783333 1141 JFK MIA 160 2.666667 725 JFK BQN 183 3.050000 461 LGA ATL 116 1.933333 6.2.4 Arrange The function arrange() can be used to sort a tibble by ascending order of the values in the specified column. If the operator - is specified before the column name, the descending order is used. The code below would produce a table showing all the rows when ordered by descending order of air time. flights_from_nyc %&gt;% dplyr::select(origin, dest, air_time) %&gt;% dplyr::arrange(-air_time) %&gt;% dplyr::slice_head(n = 5) %&gt;% knitr::kable() origin dest air_time EWR HNL 695 JFK HNL 691 JFK HNL 686 JFK HNL 686 JFK HNL 683 In the examples above, we have used slice_head to present only the first n (in the examples 5) rows in a table, based on the existing order. 6.2.5 Exercise: data manipulation The Food and Agriculture Organization (FAO) is a specialized agency of the United Nations that leads international efforts to defeat hunger. On their Website they provide comprehensive datasets on global crop and livestock production. Your task in this exercise is to create a table that shows national African sorghum production in 2019. Create an RScript and install or load the libraries tidyverse and knitr, if not done yet. Bulk download African Crop and Livestock Production data as CSV. Figure 6.1: FAO Data Download Read data from comma-separated CSV into your Script. fao_data &lt;- read.csv(directory as string, header = TRUE, sep = &quot;,&quot;) Use the pipe operator to perform the following operations: Select columns Area, Item, Element, Unit and Y2019 Filter rows that contain sorghum production (Item == Sorghum &amp; Element == Production) Group rows by country (group_by) Summarise yield in 2019 per country (Y2019) Sort the table based on yield in descending order (arrange) remove rows including No Data by means of function drop_na() render the table using the function kable() of library knitr See my solution! 6.3 Join A join operation combines two tables into one by matching rows that have the same values in the specified column. This operation is usually executed on columns containing identifiers, which are matched through different tables containing different data about the same real-world entities. For instance, the table below presents the telephone prefixes for two cities. That information can be combined with the data present in the second table below through a join operation on the columns containing the city names. As the two tables do not contain all the same cities, if a full join operation is executed, some cells have no values assigned. city_telephone_prexix &lt;- data.frame( city = c(&quot;Leicester&quot;, &quot;Birmingham&quot;, &quot;London&quot;), telephon_prefix = c(&quot;0116&quot;, &quot;0121&quot;, &quot;0171&quot;) ) %&gt;% tibble::as_tibble() city_telephone_prexix %&gt;% knitr::kable() city telephon_prefix Leicester 0116 Birmingham 0121 London 0171 city_info_wide &lt;- data.frame( city = c(&quot;Leicester&quot;, &quot;Nottingham&quot;), population = c(329839, 321500), area = c(73.3, 74.6), density = c(4500, 4412) ) %&gt;% tibble::as_tibble() city_info_wide %&gt;% knitr::kable() city population area density Leicester 329839 73.3 4500 Nottingham 321500 74.6 4412 Note that data frames in the code above are converted to so called tibbles, which is another tabular format. This step is needed as the function kable() takes tibbles as an input. The dplyr library offers different types of join operations, which correspond to the different SQL joins illustrated in the image below. Figure 6.2: Join types Please take your time to understand the example below and check out the related dplyr help pages before continuing. The first four examples execute the exact same full join operation using three different syntaxes: with or without using the pipe operator, and specifying the by argument or not. Note that all those approaches to writing the join are valid and produce the same result. The choice about which approach to use will depend on the code you are writing. In particular, you might find it useful to use the syntax that uses the pipe operator when the join operation is itself only one stem in a series of data manipulation steps. Using the by argument is usually advisable unless you are certain that you aim to join two tables with all and exactly the column that have the same names in the two table. Note how the result of the join operations is not saved to a variable. The function knitr::kable is added after each join operation through a pipe %&gt;% to display the resulting table in a nice format. # Option 1: without using the pipe operator # full join verb dplyr::full_join( # left table city_info_wide, # right table city_telephone_prexix, # columns to match by = c(&quot;city&quot; = &quot;city&quot;) ) %&gt;% knitr::kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 Nottingham 321500 74.6 4412 NA Birmingham NA NA NA 0121 London NA NA NA 0171 # Option 2: without using the pipe operator # and without using the argument &quot;by&quot; # as columns have the same name # in the two tables. # Same result as Option 1 # full join verb dplyr::full_join( # left table city_info_wide, # right table city_telephone_prexix ) %&gt;% knitr::kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 Nottingham 321500 74.6 4412 NA Birmingham NA NA NA 0121 London NA NA NA 0171 # Option 3: using the pipe operator # and without using the argument &quot;by&quot; # as columns have the same name # in the two tables. # Same result as Option 1 and 2 # left table city_info_wide %&gt;% # full join verb dplyr::full_join( # right table city_telephone_prexix ) %&gt;% knitr::kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 Nottingham 321500 74.6 4412 NA Birmingham NA NA NA 0121 London NA NA NA 0171 # Option 4: using the pipe operator # and using the argument &quot;by&quot;. # Same result as Option 1, 2 and 3 # left table city_info_wide %&gt;% # full join verb dplyr::full_join( # right table city_telephone_prexix, # columns to match by = c(&quot;city&quot; = &quot;city&quot;) ) %&gt;% knitr::kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 Nottingham 321500 74.6 4412 NA Birmingham NA NA NA 0121 London NA NA NA 0171 # Left join # Using syntax similar to Option 1 above # left join dplyr::left_join( # left table city_info_wide, # right table city_telephone_prexix, # columns to match by = c(&quot;city&quot; = &quot;city&quot;) ) %&gt;% kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 Nottingham 321500 74.6 4412 NA # Right join # Using syntax similar to Option 2 above # right join verb dplyr::right_join( # left table city_info_wide, # right table city_telephone_prexix ) %&gt;% kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 Birmingham NA NA NA 0121 London NA NA NA 0171 # Inner join # Using syntax similar to Option 3 above # left table city_info_wide %&gt;% # inner join dplyr::inner_join( # right table city_telephone_prexix ) %&gt;% kable() city population area density telephon_prefix Leicester 329839 73.3 4500 0116 6.3.1 Exercise: join In the previous exercise we have created a table that shows national African sorghum production in 2019. In this exercise we will join crop production statistics with a table that contains national boundaries and visualize sorghum production quantities in a simple map. Create an RScript and install and load the libraries tidyverse, knitr, ggplot2 and maps, if not done yet. Copy the code from the previous exercise into your new RScript. Note that the result of the pipe operations is not saved to a variable. Save it to a variable. Use the ggplot2 function map_data to convert the built in sample dataset world (comes with library maps) to a data frame world_ctry &lt;- map_data(&quot;world&quot;) Inspect the structure of this data frame. Every row represents a node (defined by long/lat) of a polygon feature. Join tables (geographic features and sorghum production statistics) based on country names. Make sure to chose a join method that allows for retaining all the geographic features. My exercise solution creates a simple output map. In a subsequent lesson we will cover visualization methods in more detail. "]]
