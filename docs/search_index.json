[["complex-data-types.html", "Lesson 3 Complex Data Types 3.1 Vectors 3.2 Multi-dimensional data types", " Lesson 3 Complex Data Types In this lession I will introduce a series of more complex data types that are built on top of the already discussed simple data types numeric, character (string) and logical (see Lesson 1 Simple data types). In this lession, you will get to know the following complex data types: Vectors Matrices and Arrays Lists Data Frames Complex data types constrain the structure that a container (such as a variable) might take. 3.1 Vectors A Vector is an ordered list of values. Vectors can be of any simple type: - numeric - character - logic However all items in a vector have to be of the same type. A vector can be of any length. Defining a vector variable is similar to the declaration of simple type variables, except that the vector is created by a return function named c() that combines values into a vector: # Declare a vector variable of strings a_vector &lt;- c(&quot;Birmingham&quot;, &quot;Derby&quot;, &quot;Leicester&quot;, &quot;Lincoln&quot;, &quot;Nottingham&quot;, &quot;Wolverhampton&quot;) a_vector ## [1] &quot;Birmingham&quot; &quot;Derby&quot; &quot;Leicester&quot; &quot;Lincoln&quot; ## [5] &quot;Nottingham&quot; &quot;Wolverhampton&quot; Note that the second line of the returned elements starts with [5], as the second line starts with the fifth element of the vector. There are also other functions to create vectors such as seq(): #create vector of real numbers of interval 0.5 in a range between 1 and 7 a_vector &lt;- seq(1, 7, by = 0.5) a_vector ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 or rep(): #create vector with 4 identical character string values a_vector &lt;- rep(&quot;Ciao&quot;, 4) a_vector ## [1] &quot;Ciao&quot; &quot;Ciao&quot; &quot;Ciao&quot; &quot;Ciao&quot; Alternatively, numeric vectors can be created by using the following syntax: #create a vector of integer numbers between 1 and 10 a_vector &lt;- (1:10) a_vector ## [1] 1 2 3 4 5 6 7 8 9 10 3.1.1 Vector element selection Each element of a vector can be retrieved specifying the related index between square brackets, after the identifier of the vector. The first element of the vector has index 1. The following, code retrieves a value of 5, which is the third element of the vector with identifier a_vector: a_vector &lt;- (3:8) a_vector[3] ## [1] 5 A vector of indexes can be used to retrieve more than one element: a_vector &lt;- (3:8) a_vector[c(2, 4)] ## [1] 4 6 The values 4 and 6 are returned. These values have the indices 2 and 4 in vector a_vector. Note that the vector containing the indices 2 and 4 is created on the fly (without assigning the return value to a variable). Now try by yourself. Create a vector that looks like east_midlands_cities &lt;- c(\"Derby\", \"Leicester\", \"Lincoln\", \"Nottingham\") , select the last three cities out of the four cities in east_midlands_cities and assign the returned values to a new vector named selected_cities. See solution! east_midlands_cities &lt;- c(\"Derby\", \"Leicester\", \"Lincoln\", \"Nottingham\") my_indexes &lt;- 2:4 selected_cities &lt;- c(east_midlands_cities[my_indexes]) 3.1.2 Functions on vectors In R, functions can be used on a vector variable in the same way they are used on simple variables. In this case, the selected function will be applied to each element of the vector. The output will be a new vector containing the same number of elements as the input vector. For instance, adding a number of ten to a vector of numbers between 1 and 5 will result in a vector of numbers between 11 and 15: a_numeric_vector &lt;- 1:5 a_numeric_vector &lt;- a_numeric_vector + 10 a_numeric_vector ## [1] 11 12 13 14 15 Accordingly, an sqrt() function applied to the same vector will return a vector containing the square root of every element as a result: a_numeric_vector &lt;- 1:5 a_numeric_vector &lt;- sqrt(a_numeric_vector) a_numeric_vector ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 We can also produce a vector of type logical by using a condition: a_numeric_vector &lt;- 1:5 a_numeric_vector &lt;- a_numeric_vector &gt;= 3 a_numeric_vector ## [1] FALSE FALSE TRUE TRUE TRUE While the condition in the example above returns an evaluation of the conditional statement for every element, the function any and all are overall expressions. The function any() returns TRUE, if any of the elements satisfy the condition: a_numeric_vector &lt;- 1:5 any(a_numeric_vector &gt;= 3) ## [1] TRUE The function all returns TRUE, if all of the elements satisfy the condition: a_numeric_vector &lt;- 1:5 all(a_numeric_vector &gt;= 3) ## [1] FALSE A factor is a data type similar to a vector. However, the values contained in a factor can only be selected from a set of levels. Factors will not be covered in the module. For more information on this data type turn to Stefano de Sabbatas video on Data Types (see min 9:30). 3.2 Multi-dimensional data types 3.2.1 Matrices So far, you have learned about one dimensional data types. Matrices are collections of numbers arranged in a two-dimensional rectangular layout. To create a matrix, two arguments should be provided to the function matrix. The first argument is a vector of values. The second specifies the number of rows and columns: a_matrix &lt;- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2)) a_matrix ## [,1] [,2] ## [1,] 3 4 ## [2,] 5 3 ## [3,] 7 1 R offers a large number of operators and functions for matrix algebra. For instance, standard mathematical operators are applicable: x &lt;- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2)) x ## [,1] [,2] ## [1,] 3 4 ## [2,] 5 3 ## [3,] 7 1 y &lt;- matrix(c(1, 2, 3, 4, 5, 6), c(3, 2)) y ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 z &lt;- x*y z ## [,1] [,2] ## [1,] 3 16 ## [2,] 10 15 ## [3,] 21 6 A more comprehensive list of matrix algebra operations is provided by Quick-R. 3.2.2 Arrays Variables of the type array are higher-dimensional matrices. Just like matrices, to create an array two arguments are required. The first argument is a vector containing the values. The second argument is a vector specifying the depth of each dimension. The following code returns a 3-dimensional array: a3dim_array &lt;- array(1:24, dim=c(4, 3, 2)) a3dim_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 3.2.3 Selection Subsetting of matrices and arrays works in a very similar way as seen for vectors. However, as these are multi-dimensional objects, one value (or index) needs to be specified for each one of the dimensions. In the example, below we are subsetting the second row and the first and second column of the matrix: a_matrix &lt;- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2)) a_matrix ## [,1] [,2] ## [1,] 3 4 ## [2,] 5 3 ## [3,] 7 1 a_matrix[2, c(1, 2)] ## [1] 5 3 As an exercise, create an arbitrary 3-dimensional array, retrieve 2 elements from it and write those elements to a new vector variable. Then retrieve 4 elements from the 3-dimensional array and write it to a new matrix variable. See solution! a3dim_array &lt;- array(1:24, dim=c(4, 3, 2)) a3dim_array a_vector &lt;- a3dim_array[3, c(1, 2), 2] a_vector a_matrix &lt;- a3dim_array[c(3, 4), c(1, 2), 2] a_matrix 3.2.4 List Variables of the type list can contain elements of different types (including vectors and matrices), whereas elements of vectors are all of the same type. In the following example, I created a list containing the simple types character and numeric integer: employee &lt;- list(&quot;Christian&quot;, 2017) employee ## [[1]] ## [1] &quot;Christian&quot; ## ## [[2]] ## [1] 2017 employee[[1]] # Note the double square brackets for selection ## [1] &quot;Christian&quot; In contrast to vectors, matrices or arrays, the selection of list elements requires the use of double square brackets. A specific type of list is the so called named list. In named lists, each element has a name, and elements can be selected using their name after the symbol $: employee &lt;- list(employee_name = &quot;Christian&quot;, start_year = 2017) employee ## $employee_name ## [1] &quot;Christian&quot; ## ## $start_year ## [1] 2017 employee$employee_name ## [1] &quot;Christian&quot; 3.2.5 Data Frame Data frames are commonly used in R to encode tables of data. A data frame is equivalent to a named list where all elements are vectors of the same length. The code below creates a data frame named employees that is composed of three vectors: employees &lt;- data.frame( EmployeeName = c(&quot;Maria&quot;, &quot;Pete&quot;, &quot;Sarah&quot;), Age = c(47, 34, 32), Role = c(&quot;Professor&quot;, &quot;Researcher&quot;, &quot;Researcher&quot;)) You can retrieve the tabular structure of the data frame employees by invoking the identifier in the code: employees ## EmployeeName Age Role ## 1 Maria 47 Professor ## 2 Pete 34 Researcher ## 3 Sarah 32 Researcher Eventually data frames are tables. Each named element is a column of the table. Given the precondition that data frames are composed of named lists where elements are vectors, is it possible to mix simple types in a vector/in a data frame column? See solution! Elements of a vector (data frame column) must be of the same type (charater, logical or numeric). In the example above, the column EmployeeName contains only character strings, the column Age contains only numeric etc. As the columns in a data frame have the same length, one element is present for each row of the table. Meaning the first element of vector EmployeeName in data frame employees is the Name of the first employee. The first element in vector Age in data frame employees is the age of the first employee etc. You can rename the columns of a data frame by means of a function called names(): names(name of data frame)[column index as number] = new column name The selection of values from a data frame is similar to what we have seen for vectors and lists. However, you have to consider the two-dimensional shape of data frames. As such, you will generally need to specify two indices in order to retrieve values from a table. The following example retrieves the first element of the first column in data frame employees: employees[1, 1] ## [1] &quot;Maria&quot; We can also retrieve entire rows employees[1, ] ## EmployeeName Age Role ## 1 Maria 47 Professor and columns: employees[ ,1] ## [1] &quot;Maria&quot; &quot;Pete&quot; &quot;Sarah&quot; Alternatively, columns can be selected by means of dollar signs and columns names: employees$Age ## [1] 47 34 32 This returns the vector Age. Accordingly, we can use square brackets to retrieve elements of the vector: employees$Age[1] ## [1] 47 To further modify the data frame, we can change elements (e.g. change the age of Pete from 34 to 33) employees$Age[2] &lt;- 33 or insert new columns as vectors (new column name Place): employees$Place &lt;- c(&quot;Salzburg&quot;, &quot;Salzburg&quot;, &quot;Salzburg&quot;) employees ## EmployeeName Age Role Place ## 1 Maria 47 Professor Salzburg ## 2 Pete 33 Researcher Salzburg ## 3 Sarah 32 Researcher Salzburg Operations can be performed on columns in the same way as on vectors. As an exercise, create a new variable, which stores the current year current_year &lt;- as.integer(format(Sys.Date(), \"%Y\")) use the column Age in data frame employees to calculate the year of birth for every employee current_year - employees$Age and insert the year of birth as a new column. See solution! #Use Sys.Date to retrieve the current year current_year &lt;- as.integer(format(Sys.Date(), \"%Y\")) #Calculate employee year of birth employees$Year_of_birth &lt;- current_year - employees$Age employees "]]
