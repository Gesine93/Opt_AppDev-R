[["read-and-write-data.html", "Lesson 9 Read and write data 9.1 Read and write tabular data 9.2 Read and write vector data 9.3 Read and write raster data 9.4 Data API 9.5 Additional Thoughts so far for revision", " Lesson 9 Read and write data In previous exercises we have read data from a CSV file into our script. Similarly we can also write code outputs to file. In this lesson you will learn to read and write plain-text, spatial vector and raster file formats. Moreover, we will retrieve online data by means of a data API. 9.1 Read and write tabular data A series of formats are based on plain-text files. For instance… comma-separated values files .csv semi-colon-separated values files .csv tab-separated values files .tsv other formats using custom delimiters fix-width files .fwf The readr library (also part of Tidyverse) provides a series of functions that can be used to load from and save to such data formats. For instance, the read_csv function reads a comma delimited (CSV) file from the path provided as the first argument. The code example below reads a CSV file that contains global fishery statistics provided by the World Bank and queries Norwegian entries. The function writes_csv writes these entries to a new CSV file. library(tidyverse) fishery_data &lt;- readr::read_csv(&quot;data/capture-fisheries-vs-aquaculture.csv&quot;) #print(fishery_data) #print(typeof(fishery_data$)) fishery_data %&gt;% dplyr::filter(Entity == &quot;Norway&quot;) %&gt;% readr::write_csv(&quot;data/capture-fisheries-vs-aquaculture-norway.csv&quot;, append=FALSE) %&gt;% dplyr::slice_head(n = 3) %&gt;% knitr::kable() Entity Code Year Aquaculture production (metric tons) Capture fisheries production (metric tons) Norway NOR 1960 1900 1609362 Norway NOR 1961 900 1758413 Norway NOR 1962 200 1572913 In order to run the script, download the CSV file. Then copy and run the code in a new R-script. Other important packages for reading tabular data are readxl for Excel (.xls and .xlsx) and haven for SPSS, Stata and SAS data. 9.2 Read and write vector data The library sf makes it easy to read and write vector datasets such as shapefiles. Remember: We have used the sf-library in lesson Spatial Data Structures to build vector geometries from scratch, investigate their properties and assign and transform coordinate reference systems. The name sf stands for simple features, meaning that sf-objects conform to the simple feature standard. Now we use the same library to load sf-objects from file. In order to load vector data in an R-Script, we can use the function st_read(). In the code block below, a shapefile (North Carolina sample data) is loaded and assigned to a variable nc. The next line creates a basic map in sf by means of plot(). By default this creates a multi-panel plot, one sub-plot for each variable (attribute) of the sf-object. library(sf) nc &lt;- sf::st_read(&quot;data/nc.shp&quot;) plot(nc) As you have learned in lesson Spatial Data Structures, sf represents features as records in data-frame-like structures with an additional geometry list-column. The example below renders three features (rows) of variable nc including the geometry column of type MULTIPOLYGON (see Simple feature geometry types) as well as the attributes AREA (feature area) and NAME (name of county): nc %&gt;% dplyr::select(AREA, NAME, geometry) %&gt;% dplyr::slice_head(n = 3) %&gt;% knitr::kable() AREA NAME geometry 0.114 Ashe MULTIPOLYGON (((-81.47276 3… 0.061 Alleghany MULTIPOLYGON (((-81.23989 3… 0.143 Surry MULTIPOLYGON (((-80.45634 3… sf also includes a number of operations to manipulate the geometry of features such as st_simplify: sf::st_simplify(nc) %&gt;% plot(., max.plot = 1) You may have recognized that a dot (.) is used as a parameter in the function plot(). The dot represents the piped value. In the example above the dot is used to define the simplified geometry of nc as first parameter of function plot() and max.plot = 1 as the second. In the next example, the st_geometry() retrieves the geometry attribute from variable nc, function st_centroid() calculates the centroid of the polygon geometry (counties) and function st_write writes the centroid point geometry to file. sf::st_geometry(nc) %&gt;% sf::st_centroid() %&gt;% sf::st_write(&quot;data/nc-centroids.shp&quot;, delete_dsn = TRUE) %&gt;% plot(pch = 3, col = &#39;red&#39;) The online book Geocomputation with R offers a more comprehensive explanation of available geometric, attribute and spatial data operations. For a quick overview, you may turn to the sf cheatsheets. In order to test the code on your machine, download the North Carolina dataset and install the libraries sf and Rcpp before you run the code in an R-Script. The plot() function offers a large number of arguments that can be used to customize your map. Replace ‘Area’ in the map above by a more meaningful map title. Turn to the documentation for more information. See my solution! 9.3 Read and write raster data The terra library provides functions to read and write raster data. In lesson Spatial Data Structures we have used terra to build SpatRaster Objects from scratch, investigated their properties and assigned and transformed coordinate reference systems. It is more common, however, to create a SpatRaster Object from a file. Supported file formats for reading are GeoTIFF, ESRI, ENVI, and ERDAS. Most formats supported for reading can also be written to (see Creating SpatRaster objects). The following code reads a GeoTIFF (download venice-Sentinel.tiff 712KB) into memory and assigns it to a variable named `r``: library(terra) r &lt;- terra::rast(&quot;data/venice-Sentinel.tiff&quot;) The function hasValues returns the logic value TRUE, which indicates that in-memory layers have cell values: terra::hasValues(r) ## [1] TRUE Executing the variable name r returns additional metadata information, which among others reveals that the image has 4 layers: r ## class : SpatRaster ## dimensions : 503, 692, 4 (nrow, ncol, nlyr) ## resolution : 7.025638, 6.675899 (x, y) ## extent : 288674.2, 293535.9, 5033073, 5036431 (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 33N (EPSG:32633) ## source : venice-Sentinel.tiff ## names : venice-Sentinel_1, venice-Sentinel_2, venice-Sentinel_3, venice-Sentinel_4 Layers 1-3 correspond to color bands red, green and blue. In order to plot the true color sentinel imagery, we can use terra function plotRGB and assign the numbers of respective color bands to attributes r (red), g (greeb), b (blue): terra::plotRGB(r, r=1, g=2, b=3, main=&quot;Sentinel-2 image of Venice&quot;) The following line converts the original CRS (which is WGS 84 / UTM zone 33N) to the Italian national CRS Italy Zone 1: r_z1 &lt;- terra::project(r, &quot;+proj=tmerc +lat_0=0 +lon_0=9 +k=0.9996 +x_0=1500000 +y_0=0 +ellps=intl +units=m +no_defs&quot;) Eventually, the modified SpatRaster Object is written to file by means of terra function writeRaster: terra::writeRaster(r_z1, &quot;data/venice_zone1.tif&quot;, overwrite=TRUE) 9.4 Data API API is the acronym for Application Programming Interface, which is a software intermediary that allows two applications to talk to each other. By means of an API we can read, write and modify information on the web. The following video briefly introduces the technology behind it. Figure 9.1: Video (3:13 min): REST API concepts and examples. The most important take away messages are: With a REST API web data is accessible through a URL (Client-Server call via HTTP protocol) The HTTP Get Method delivers data (a Response) - i.e. is used to read data, the HTTP Post Method is used to create new REST API resources (write data). URL Parameters are used to filter specific data from a response. Typically, APIs can return data in a number of different formats. JSON is a very popular format for transferring web data. The two primary elements that make up JSON are keys and values. The library httr2 offers functions to programmatically implement API calls in an R script. We will make use of this library to let our R script interact with the APIs offered by OpenWeather Map. that contain historical and real-time weather data for retrieval. In the upcoming example we will make a call to the Current Weather API, which is one out of currently 10 free APIs provided by OpenWeather Map. For accessing the data with httr2, we’ll construct a URL composed of a reference to the data source (base) and parameters to filter the desired data subset (lat and lon). In httr2, the URL and query parameters can be separated, simplifying the process. The parameters are passed as a named list to the request() function: library(httr2) # Define the base URL and parameters base &lt;- &quot;http://api.openweathermap.org/data/2.5/weather&quot; lat &lt;- &quot;47.81&quot; lon &lt;- &quot;13.03&quot; apiKey &lt;- &quot;3f87141421b32590d50416aae5ca780c&quot; # Construct the full URL with query parameters using sprintf full_url &lt;- sprintf(&quot;%s?lat=%s&amp;lon=%s&amp;appid=%s&quot;, base, lat, lon, apiKey) # Display the constructed URL print(full_url) ## [1] &quot;http://api.openweathermap.org/data/2.5/weather?lat=47.81&amp;lon=13.03&amp;appid=3f87141421b32590d50416aae5ca780c&quot; In the code above, the function sprintf() assembles the base URL and parameters. The URL (of type string) will then pass the request() function to create a request object, and req_perform() is used to execute the HTTP Get method. Note: The OpenWeather API requires an API Key to be passed as a parameter in the call. Get your personal Key to implement your own API requests. If your code returns an error 401, this most likely indicates that your key is not activated yet. According to the FAQs, it may take a couple of hours until your key is active. By default, the req_perform() function returns a response object. Printing a response object provides useful information such as the actual URL used (after any redirects), the HTTP status, and the content type. You can extract important parts of the response with various helper functions such as resp_status() and resp_body_json(): # Create the request and perform it req &lt;- request(full_url) resp &lt;- req_perform(req) # Check the status code of the response print(resp_status(resp)) ## [1] 200 # View the content structure of the response in JSON str(resp_body_json(resp)) ## List of 13 ## $ coord :List of 2 ## ..$ lon: num 13 ## ..$ lat: num 47.8 ## $ weather :List of 1 ## ..$ :List of 4 ## .. ..$ id : int 800 ## .. ..$ main : chr &quot;Clear&quot; ## .. ..$ description: chr &quot;clear sky&quot; ## .. ..$ icon : chr &quot;01d&quot; ## $ base : chr &quot;stations&quot; ## $ main :List of 6 ## ..$ temp : num 299 ## ..$ feels_like: num 299 ## ..$ temp_min : num 297 ## ..$ temp_max : num 301 ## ..$ pressure : int 1017 ## ..$ humidity : int 45 ## $ visibility: int 10000 ## $ wind :List of 2 ## ..$ speed: num 2.06 ## ..$ deg : int 150 ## $ clouds :List of 1 ## ..$ all: int 0 ## $ dt : int 1697198665 ## $ sys :List of 5 ## ..$ type : int 1 ## ..$ id : int 6877 ## ..$ country: chr &quot;AT&quot; ## ..$ sunrise: int 1697174584 ## ..$ sunset : int 1697214304 ## $ timezone : int 7200 ## $ id : int 2766824 ## $ name : chr &quot;Salzburg&quot; ## $ cod : int 200 The Current Weather API call returned a number of real-time weather variables such as temperature, air pressure or humidity for the location of Salzburg. Current weather data may alternatively be retrieved by City ID or City Name (see the documentation to get an overview of available API parameters). Inspect the response object by means of a function called headers(). What methods are allowed when accessing the Current Weather API? See solution! Only GET and POST methods are allowed. Other APIs allow to update existing REST API resources (PUT method) or to delete a REST API resource (DELETE method). To facilitate subsequent analyses and data visualization, we can convert the content of the return object to a data frame. With httr2, you can directly retrieve the JSON content and convert it to a data frame: # Using resp_body_json to get the JSON content of the response response_content &lt;- resp_body_json(resp) response_df &lt;- as.data.frame(response_content) response_df ## coord.lon coord.lat weather.id weather.main weather.description weather.icon ## 1 13.03 47.81 800 Clear clear sky 01d ## base main.temp main.feels_like main.temp_min main.temp_max main.pressure ## 1 stations 298.95 298.76 296.79 300.87 1017 ## main.humidity visibility wind.speed wind.deg all dt sys.type sys.id ## 1 45 10000 2.06 150 0 1697198665 1 6877 ## sys.country sys.sunrise sys.sunset timezone id name cod ## 1 AT 1697174584 1697214304 7200 2766824 Salzburg 200 Copy the code snippets above to a new R-Script. Make sure to replace the key in the code example by your own API key! If you need help, please turn to the discussion forum. Note: If you want more advanced JSON manipulation or flattening, you can still use the jsonlite library. But for the basic conversion shown here, it’s not necessary. Tidyverse also provides other packages for reading data such as DBI for relational databases jsonlite for JSON and xml2 for XML. … more to come! 9.5 Additional Thoughts so far for revision 9.5.1 7.4 Advanced JSON Handling with httr2 While touched on converting API responses to data frames using jsonlite, we could delve deeper into JSON handling: Parsing Nested JSON: Often, APIs return nested JSON structures. Teach how to handle and flatten these structures to convert them into usable data frames. JSON to List: Before converting to a data frame, JSON can be converted to a list in R. This can be useful for certain types of analyses or data manipulations. 9.5.2 7.5 Caching Data with httr2 Given that httr2 has caching capabilities, this can be a valuable addition: Why Cache?: Explain the benefits of caching, especially when dealing with rate-limited APIs or to speed up development and analysis by not fetching data repeatedly. Implementing Caching: Show how to use req_cache() in httr2 to cache API responses. 9.5.3 7.6 Error Handling and Retries with httr2 Building on the capabilities of httr2: Understanding HTTP Errors: Briefly explain common HTTP errors like 404 (Not Found) or 429 (Too Many Requests) and why they might occur when working with APIs. Implementing Retries: Show how to use req_retry() in httr2 to automatically retry if a request fails. 9.5.4 7.7 Advanced API Techniques Pagination: Many APIs return data in pages, especially if there’s a lot of data. Teach how to handle paginated responses and fetch all data. Rate Limiting: Explaining what rate limiting is and how to handle it, possibly by introducing pauses in requests or by using caching. 9.5.5 7.8 Introduction to Web Scraping (Altough, this might be too much.. and even if it’s important, for data sourcing, it’s kind of a grey area, limited by rate limits or considerations with ToS.) While APIs are a clean way to get data, not all websites offer them. We could introduce the concept of web scraping: What is Web Scraping?: Briefly explain the concept and why it might be necessary. Using rvest for Web Scraping: Introduce the rvest package, which is part of the tidyverse and is used for web scraping. We could provide a simple example of scraping data from a website. Morality of Web Scraping: via. Ethical, Legal, Technical Considerations "]]
